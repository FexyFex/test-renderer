#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

struct GeneralInfo {
    mat4 view;
    mat4 proj;
};

struct ObjectInfo {
    ivec3 pos;
    int instanceCount;
    int firstInstance;
    int dum1;
    int dum2;
    int dum3;
};

struct Plane {
    vec3 normal;
    float distance;
};

struct Frustum {
    vec4 topFace;
    vec4 bottomFace;
    vec4 rightFace;
    vec4 leftFace;
    vec4 farFace;
    vec4 nearFace;
};

struct AABB {
    vec3 center;
    vec3 extents;
};

struct DrawIndirectCommand {
    int vertexCount;
    int instanceCount;
    int firstVertex;
    int firstInstance;
};


layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0) uniform UBO { GeneralInfo info; } cameraBuffer[];
layout (set = 0, binding = 3) buffer InSBO { ObjectInfo objInfos[]; } objInfoBuf[];
layout (set = 0, binding = 3) buffer OutSBO { ivec4 commands[]; } outBuf[];
layout (set = 0, binding = 3) buffer PosSBO { ivec4 chunkPos[]; } posBuf[];

layout(push_constant) uniform PushConstants{
    uint cameraBufferIndex;
    uint objInfoBufferIndex;
    uint commandBufferIndex;
    uint chunkPosBufferIndex;
    uint sidePosBufferIndex;
};

vec3 unproject(vec3 sp, mat4 invView, mat4 invProj) {
    vec4 vp = invProj * vec4(sp, 1.0);
    vp /= vp.w;
    return vec3(invView * vp);
}

vec4 plane(vec3 p0, vec3 p1, vec3 p2) {
    vec3 n = normalize(cross(p1 - p0, p2 - p0));
    return vec4(n, dot(n, p0));
}
Frustum createFrustum() {
    Frustum frustum;

    GeneralInfo cam = cameraBuffer[cameraBufferIndex].info;

    mat4 invView = inverse(cam.view);
    mat4 invProj = inverse(cam.proj);

    vec3 p000 = unproject(vec3(-1.0f, -1.0f, -1.0f), invView, invProj);
    vec3 p001 = unproject(vec3(-1.0f, -1.0f, +1.0f), invView, invProj);
    vec3 p010 = unproject(vec3(-1.0f, +1.0f, -1.0f), invView, invProj);
    vec3 p011 = unproject(vec3(-1.0f, +1.0f, +1.0f), invView, invProj);
    vec3 p100 = unproject(vec3(+1.0f, -1.0f, -1.0f), invView, invProj);
    vec3 p101 = unproject(vec3(+1.0f, -1.0f, +1.0f), invView, invProj);
    vec3 p110 = unproject(vec3(+1.0f, +1.0f, -1.0f), invView, invProj);

    // near
    frustum.nearFace = plane(p000, p100, p010);
    // far
    frustum.farFace = plane(p001, p011, p101);

    // left
    frustum.leftFace = plane(p000, p010, p001);
    // right
    frustum.rightFace = plane(p100, p101, p110);

    // bottom
    frustum.bottomFace = plane(p000, p001, p100);
    // top
    frustum.topFace = plane(p010, p110, p011);

    return frustum;
}

AABB createAABB(ObjectInfo obj, ivec3 cameraPos) {
    AABB aabb;
    vec3 pos = obj.pos;// - cameraPos;
    aabb.center = vec3(pos.x + 8.0, pos.y + 8.0, pos.z + 8.0);
    aabb.extents = vec3(8.0, 8.0, 8.0);
    return aabb;
}

float getSignedDistanceToPlane(vec4 plane, vec3 point) {
    return dot(plane.xyz, point) - plane.w;
}

bool isInFrontOfPlane(AABB aabb, vec4 plane) {
    const float r = aabb.extents.x * abs(plane.x) + aabb.extents.y * abs(plane.y) + aabb.extents.z * abs(plane.z);
    return -r <= getSignedDistanceToPlane(plane, aabb.center);
}

void main() {
    uint gID = gl_GlobalInvocationID.x;

    ObjectInfo objInfo = objInfoBuf[objInfoBufferIndex].objInfos[gID];
    objInfo.pos *= 16;

    // calculation for frustum culling
    GeneralInfo cam = cameraBuffer[cameraBufferIndex].info;
    Frustum frustum = createFrustum();
    AABB aabb = createAABB(objInfo, /*cam.cameraChunkPos * 16*/ ivec3(0));

    bool isInView =
        isInFrontOfPlane(aabb, frustum.leftFace) &&
        isInFrontOfPlane(aabb, frustum.rightFace) &&
        isInFrontOfPlane(aabb, frustum.topFace) &&
        isInFrontOfPlane(aabb, frustum.bottomFace) &&
        isInFrontOfPlane(aabb, frustum.nearFace) &&
        isInFrontOfPlane(aabb, frustum.farFace);

    int instanceCount = int(isInView) * objInfo.instanceCount;

    outBuf[commandBufferIndex].commands[gID] = ivec4(4, instanceCount, 0, objInfo.firstInstance);
    posBuf[chunkPosBufferIndex].chunkPos[gID] = ivec4(objInfo.pos, 0);
}
