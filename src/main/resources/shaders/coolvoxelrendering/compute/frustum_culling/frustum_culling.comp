#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

struct GeneralInfo {
    mat4 view;
    mat4 proj;
    ivec3 cameraChunkPos;
};

struct ObjectInfo {
    ivec3 pos;
    int extent;
    int indexCount;
    int firstIndex;
    int firstVertex;
    int dummy; // 32 byte alignment. Hope it works.
};

struct Plane {
    vec3 normal;
    float distance;
};

struct Frustum {
    vec4 topFace;
    vec4 bottomFace;
    vec4 rightFace;
    vec4 leftFace;
    vec4 farFace;
    vec4 nearFace;
};

struct AABB {
    vec3 center;
    vec3 extents;
};

struct DrawIndexedIndirectCommand {
    int indexCount;
    int instanceCount;
    int firstIndex;
    int firstVertex;
    int firstInstance;
};

struct ChunkPos {
    ivec4 chunkPos;
    ivec4 dummy;
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0) uniform UBO { GeneralInfo info; } uniformBuffers[];
layout (set = 1, binding = 0) uniform texture2D textures[];
layout (set = 2, binding = 0) uniform sampler samplers[];
layout (set = 3, binding = 0) buffer InSBO { ObjectInfo objInfo[]; } inBuf[];
layout (set = 3, binding = 0) buffer OutSBO { DrawIndexedIndirectCommand commands[]; } outBuf[];
layout (set = 3, binding = 0) buffer PosSBO { ChunkPos chunkPos[]; } posBuf[];

layout(push_constant) uniform PushConstants{
    uint indices;
};


uint getIndex(int indexSlot) {
    int shift = (8 * indexSlot);
    return (indices & (255 << shift)) >> shift;
}

vec3 unproject(vec3 sp, mat4 invView, mat4 invProj) {
    vec4 vp = invProj * vec4(sp, 1.0);
    vp /= vp.w;
    return vec3(invView * vp);
}

vec4 plane(vec3 p0, vec3 p1, vec3 p2) {
    vec3 n = normalize(cross(p1 - p0, p2 - p0));
    return vec4(n, dot(n, p0));
}
Frustum createFrustum() {
    Frustum frustum;

    GeneralInfo cam = uniformBuffers[getIndex(0)].info;

    mat4 invView = inverse(cam.view);
    mat4 invProj = inverse(cam.proj);

    vec3 p000 = unproject(vec3(-1.0f, -1.0f, -1.0f), invView, invProj);
    vec3 p001 = unproject(vec3(-1.0f, -1.0f, +1.0f), invView, invProj);
    vec3 p010 = unproject(vec3(-1.0f, +1.0f, -1.0f), invView, invProj);
    vec3 p011 = unproject(vec3(-1.0f, +1.0f, +1.0f), invView, invProj);
    vec3 p100 = unproject(vec3(+1.0f, -1.0f, -1.0f), invView, invProj);
    vec3 p101 = unproject(vec3(+1.0f, -1.0f, +1.0f), invView, invProj);
    vec3 p110 = unproject(vec3(+1.0f, +1.0f, -1.0f), invView, invProj);

    // near
    frustum.nearFace = plane(p000, p100, p010);
    // far
    frustum.farFace = plane(p001, p011, p101);

    // left
    frustum.leftFace = plane(p000, p010, p001);
    // right
    frustum.rightFace = plane(p100, p101, p110);

    // bottom
    frustum.bottomFace = plane(p000, p001, p100);
    // top
    frustum.topFace = plane(p010, p110, p011);

    return frustum;
}

AABB createAABB(ObjectInfo obj, ivec3 cameraPos) {
    AABB aabb;
    vec3 pos = obj.pos - cameraPos;
    aabb.center = vec3(pos.x + (obj.extent / 2.0), pos.y + (obj.extent / 2.0), pos.z +(obj.extent / 2.0));
    aabb.extents = vec3(obj.extent / 2.0, obj.extent / 2.0, obj.extent / 2.0);
    return aabb;
}

float getSignedDistanceToPlane(vec4 plane, vec3 point) {
    return dot(plane.xyz, point) - plane.w;
}

bool isInFrontOfPlane(AABB aabb, vec4 plane) {
    const float r = aabb.extents.x * abs(plane.x) + aabb.extents.y * abs(plane.y) + aabb.extents.z * abs(plane.z);
    return -r <= getSignedDistanceToPlane(plane, aabb.center);
}

void main() {
    uint gID = gl_GlobalInvocationID.x;

    ObjectInfo objInfo = inBuf[getIndex(1)].objInfo[gID];

    DrawIndexedIndirectCommand drawCommand;
    drawCommand.indexCount = objInfo.indexCount;
    drawCommand.instanceCount = 0;
    drawCommand.firstInstance = 0;
    drawCommand.firstIndex = objInfo.firstIndex;
    drawCommand.firstVertex = objInfo.firstVertex;

    // calculation for frustum culling
    GeneralInfo cam = uniformBuffers[getIndex(0)].info;
    Frustum frustum = createFrustum();
    AABB aabb = createAABB(objInfo, cam.cameraChunkPos * 16);

    //vec3 right = vec3(aabb.extents.x, 0.0, 0.0);
    //vec3 up = vec3(0.0, aabb.extents.y, 0.0);
    //vec3 forward = vec3(0.0, 0.0, aabb.extents.z);

    bool isInView =
        isInFrontOfPlane(aabb, frustum.leftFace) &&
        isInFrontOfPlane(aabb, frustum.rightFace) &&
        isInFrontOfPlane(aabb, frustum.topFace) &&
        isInFrontOfPlane(aabb, frustum.bottomFace) &&
        isInFrontOfPlane(aabb, frustum.nearFace) &&
        isInFrontOfPlane(aabb, frustum.farFace);

    if (isInView) {
        drawCommand.instanceCount = 1;
        drawCommand.firstInstance = int(gID);
    }

    ChunkPos chunkThingy;
    chunkThingy.chunkPos = ivec4(objInfo.pos, 0);
    posBuf[getIndex(3)].chunkPos[gID] = chunkThingy;

    outBuf[getIndex(2)].commands[gID] = drawCommand;
}
