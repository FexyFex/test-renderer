#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#include "./raycommon.glsl"
#include "./intersection_lib.glsl"


layout(set = 0, binding = 3) buffer DebugBuffer { float arr[]; } debugBuffer;
layout(set = 0, binding = 4) buffer AABBs { AABB arr[]; } aabbs;
layout(set = 0, binding = 5) buffer OctreeBuffer { int arr[]; } octreeBuffer;

hitAttributeEXT vec3 hitPosition;


int getOctantIndexOfGlobalPositionInMipLevel(vec3 globalPos, int mipLevel) {
    int mipExtent = extent >> mipLevel;
    vec3 rel = floor(globalPos / mipExtent);
    vec3 mid = (rel * mipExtent) + (mipExtent / 2.0);
    int x = int(globalPos.x >= mid.x);
    int y = int(globalPos.y >= mid.y);
    int z = int(globalPos.z >= mid.z);
    return x | (y << 1) | (z << 2);
}

void main() {
    vec3 rayOrigin = gl_WorldRayOriginEXT;
    vec3 rayDirection = gl_WorldRayDirectionEXT;

    AABB aabb = aabbs.arr[gl_PrimitiveID];

    vec2 t;
    int hitKind;
    if (mod(gl_PrimitiveID, 2) != 0) {
        t = intersectSphere(rayOrigin, rayDirection, aabb);
        hitKind = HIT_KIND_SPHERE;
    } else {
        t = intersectAABB(rayOrigin, rayDirection, aabb);
        hitKind = HIT_KIND_AABB;
    }

    hitPosition = mod(rayOrigin + t.x * rayDirection, 1.0);
    reportIntersectionEXT(t.x, hitKind);
    hitPosition = mod(rayOrigin + t.y * rayDirection, 1.0);
    reportIntersectionEXT(t.y, hitKind);
}